<resources>
    <string name="app_name">BackgroundOperations</string>

    <string name="handler_name">HANDLER OPERATION</string>
    <string name="background_service_name">BACKGROUND SERVICE OPERATION</string>
    <string name="foreground_service_name">FOREGROUND SERVICE OPERATION</string>
    <string name="coroutine_name">COROUTINE OPERATION</string>

    <string name="start_thread">START THREAD</string>
    <string name="stop_thread">STOP THREAD</string>

    <string name="download_start">DOWNLOAD DATA</string>
    <string name="download_stop">STOP DOWNLOAD</string>
    <string name="more_on_coroutines">COROUTINES</string>

    <string name="start_service">START SERVICE</string>
    <string name="stop_service">STOP SERVICE</string>

    <string name="handler_explanation">A Handler allows communicating back with UI thread from other
        background thread. A Handler allows you to send and process Message and Runnable objects associated
        with a thread’s MessageQueue. Each Handler instance is associated with a single thread and that thread’s
        message queue.</string>
    <string name="background_service_explanation">Background Services does not need user intervention. These services do
        not update users about the background tasks and users cannot access them. The processes such as Download Data from server,
        syncing of data, storing data come under this service. This service runs only when the app is running and the service gets terminated
        when the app is terminated.</string>
    <string name="background_operations_explanation">In Android development, background operations refer to tasks that run independently of the UI, ensuring main thread remains free
     to handle user interactions. These operations are essential for performing tasks that take time, such as network requests, syncing data, location updates, fetching database content, etc. Modern Android
    versions have introduced restrictions on background execution to improve battery life and system performance, thereby encouraging developers to use more efficient methods for background tasks.</string>
    <string name="foreground_service_explanation">Foreground Services update the user about its ongoing operations. Users can interact with
        the service by notifications provided about the ongoing task. Ex: Downloading file (user can keep track of progress),
        Music player app, Fitness app records user’s fitness elements, Navigation app. Unless the Foreground Service is stopped by the application,
        the service keeps running even though the app is closed.
    </string>
    <string name="bound_service_explanation">Bound Service runs only if the component it is bound to is still active. A bound service runs only as long as
    another application component is bound to it. Multiple components can bind to the service at once, but when all of them unbind, the service is destroyed.</string>
    <!-- Coroutine -->
    <string name="coroutine_explanation">In Kotlin, a coroutine is a concurrency design pattern that facilitates writing asynchronous code in a sequential and readable style. They are often described as \"lightweight threads\" because they enable concurrent
        execution of tasks without the overhead associated with traditional threads. In the world of Kotlin, a coroutine is a piece of code that can be suspended and resumed without blocking the executing thread.</string>
    <!-- Coroutine builders -->
    <string name="coroutine_builders">Coroutine builders create and launch coroutines. These builders offer a way to start
        coroutines in various contexts and are essential for managing concurrent operations effectively.</string>
    <string name="cor_builders_launch">It is used for fire and forget tasks or tasks that do not need to return a value. This function returns a Job object that launches a new coroutine without blocking the current thread, inherits the thread and coroutine scope of the immediate parent coroutine</string>
    <string name="cor_builders_async">Async is known for parallel execution of different tasks as it waits for all the tasks to be completed and returns \"deferred\" object. It calls the suspending function \"await\" on the deferred value
        to wait and get the result. Like launch, async runs without blocking the main thread.</string>
    <string name="cor_builders_runblocking">runBlocking blocks the current thread on which it is invoked until the coroutine is completed. It runs
        the coroutine in the context on the thread it is invoked. It is mainly used for testing or bridging non-suspending code
        with suspending code.</string>
    <!-- Coroutine Scopes -->
    <string name="coroutine_scope_explanation">Defines a scope for new coroutines to establish a structured way to manage their lifecycles and ensure proper resource management. A CoroutineScope is typically tied to a specific component or lifecycle, such as an android activity, fragment or viewmodel. When the associated
     component is destroyed or its lifecycle ends, any coroutines launched within that scope are automatically canceled except Global Scope whose life cycle is tied to the entire application.\n\n<b>Without dispatcher - Dispatchers.Default:</b>\nUses a shared pool of background threads (worker threads)\nGlobalScope.launch{…}
        - Runs in one of the worker threads\n\nlifecycleScope.launch { … } runs on the main thread by default.\n\nviewModelScope.launch { … } runs on the main thread by default.</string>
    <string name="cor_scope_global">This scope is a predefined global scope that lives as long as your application is running. It is not tied to any lifecycle, and the user need to be cautious while using it may lead to resource leaks or uncontrolled coroutines if not managed properly. Prefer viewModelScope, lifecycleScope, or CoroutineScope
        tied to your component lifecycle.</string>
    <string name="cor_scope_coroutine">This scope is tied to a specific component or context, such as an Activity, Fragment, or ViewModel. It is a best practice to create a custom CoroutineScope for each of these components to manage efficiently. When the component is
        destroyed, all the coroutines within its scope are automatically canceled.</string>
    <string name="cor_scope_lifecycle">This is an extension property from the androidx.lifecycle library, available for android components such as Activity and Fragment. It creates a CoroutineScope tied to the lifecycle of the component, ensuring that coroutines are canceled when the component is destroyed.</string>
    <string name="cor_scope_viewmodel">This is another extension property available for Android ViewModel classes (from the androidx.lifecycle library) that automatically creates a CoroutineScope tied to the ViewModel\'s lifecycle. It is ideal for performing asynchronous tasks within ViewModels.</string>
    <!-- Coroutine Dispatchers -->
    <string name="coroutine_dispatcher_explanation">Dispatchers are responsible for assigning coroutines to specific threads or thread pools. They control the threading behaviour of coroutines, allowing user to specify which thread should execute a particular coroutine. In other terms, Dispatchers allow users to optimize
    coroutine execution based on the type of task. For ex: user can offload long-running I/O operations to a background thread pool using Dispatchers.IO to prevent blocking the main thread and thereby keeping UI responsive.</string>
    <string name="cor_dispatchers_io">I/O dispatcher is designed to handle system input/output operations in our code. Coroutines running on the IO dispatcher would not block the main thread.
    This is suitable for IO intensive tasks such as reading and writing files, performing db queries or making network requests.</string>
    <string name="cor_dispatchers_default">To perform CPU intensive functions, default dispatcher is used. Used for operations such as heavy calc like matrix multiplications, bigger list sorting,
    filtering, searching, etc., scaling the bitmap available in memory, parsing the JSON available in memory.</string>
    <string name="cor_dispatchers_unconfined">This dispatcher is not restricted to a particular thread. It starts a coroutine in the caller thread (corresponds to parent thread), but only until the
    first suspension point. After the suspension it resumes the coroutine in a different thread.</string>
    <string name="cor_dispatchers_main">Used in Android apps when user wants to interact with the UI. It is restricted to the main thread. Ex: Perform UI-related tasks</string>
    <string name="cor_coroutine_context">The intended purpose of CoroutineContext parameter in launch is to provide additional context elements to override elements that would be otherwise inherited from a parent scope.
         CoroutineContext inherits from parent scope or from scope within its running (flow context from parent to child)</string>
    <!-- Essential Tools -->
    <string name="essential_tools_work_manager">WorkManager is an Android Jetpack library that provides a flexible and efficient way to schedule and manage background tasks in your app.  With WorkManager, you can schedule asynchronous, deferred, and periodic tasks that need to run even when the app is not in the foreground.
    WorkManager supports three different types of work requests:\n\n OneTimeWorkRequest, PeriodicWorkRequest, CoroutineWorker</string>
    <string name="essential_tools_work_manager_example">In this screen, a background task that displays a notification is scheduled. On pressing the button on screen, after a minute, Worker Class doWork() gets called by WorkManager to perform the background task. This is a one time notification as we mentioned OneTimeWorkRequest by defining a WorkRequest object.</string>
    <string name="essential_tools_alarm_manager_example">Alarm Manager is used in tasks requiring exact timing, such as setting alarms or reminders. In this example, a notification is sent after 5 seconds of user pressing the button. This is achieved using Alarm manager object calling setExactAndAllowWhileIdle(), which is used for one-time alarm fired on the given time,
    using Pending Intent (token that can be passed to another application or the system to perform an action on user\'s behalf) and using Broadcast operations along with Service() (to send events) and BroadcastReceiver() (to receive events).</string>
    <string name="essential_tools_job_scheduler">JobScheduler is designed for scheduling jobs based on specific conditions like network connectivity or charging status. Job scheduler allows developers to schedule background tasks (jobs) to run at a specific time, when certain conditions are met or on a recurring basis. It provides more
        control over job constraints but does not handle Doze mode as efficiently as WorkManager. It is designed to optimize battery usage and system resources by allowing the system to group and execute jobs together.</string>
    <string name="essential_tools_alarm_manager">Alarm Manager is used for scheduling tasks to occur at precise times or intervals. It can trigger alarms at exact times, which is vital for some use cases (session timeout).</string>
    <string name="essential_tools_executor_service"></string>
    <!-- Launch Modes -->
    <string name="launch_mode">Android launch modes define how activities are launched and managed within the activity stack. They determine whether a new instance of an activity is created or an existing one is reused. There are four primary launch modes:\n\n<b>Standard:</b>\n<b>Default Mode</b> (if none is specified)\n<b>Behaviour:</b>A new instance of the activity is created every time
        it\'s launched.\n<b>Use case:</b> Ideal for activities that can be opened multiple times independently.\n<b>Example:</b>Launching Activity B from Activity A multiple times results in multiple B instances.\n\n<b>SingleTop:</b>\n<b>Behaviour:</b>If the activity is already at the top of the stack, no new instance is created. Instead, onNewIntent() is called.\n<b>Use case:</b> Useful for activities
        that should not be duplicated if already visible.\n<b>Example:</b>Notifications opening the same activity repeatedly.\n\n<b>SingleTask:</b>\n<b>Behavior:</b> Only one instance of the activity exists across the entire system. If it exists, it\'s reused and all activities above it are cleared.\n<b>Use case:</b> For activities that should act as entry points or reset navigation (e.g., home screen).
        \n<b>Example:</b> Launching Activity B (singleTask) from Activity A clears any intermediate activities and brings B to the front.\n\n<b>SingleInstance:</b>\n<b>Behavior:</b> Like singleTask, but the activity runs in its own separate task. No other activities can be part of that task.\n<b>Use case:</b> Rarely used; suitable for activities that must remain isolated (e.g., secure login screens).\n
        <b>Example:</b> Activity B (singleInstance) always launches in a new task and remains the only activity in that task.\n\nThese modes are declared in the AndroidManifest.xml using the android:launchMode attribute or set programmatically via Intent flags. Understanding them is key to managing navigation and memory efficiently in Android apps.
    </string>
    <string name="launch_mode_flags">Intent Flags are special constants used to modify how activities are launched and behave in the task stack. They work alongside launch modes to give developers fine-grained control over navigation and activity lifecycle. Flags can override or complement launch modes. For example, combining FLAG_ACTIVITY_NEW_TASK with FLAG_ACTIVITY_CLEAR_TASK ensures a completely fresh start.
    \n\nFLAG_ACTIVITY_NEW_TASK:\nStarts the activity in a new task. Required when starting an activity from a non-activity context (like a service).\nUse Case: Launching from a service or broadcast receiver. In the activities screen, A goes to B (singleTask) while A is still on the stack. Because B\'s existence is not there yet. Android creates a new task of B at the root only if the intent has FLAG_ACTIVITY_NEW_TASK
        \n\nFLAG_ACTIVITY_CLEAR_TOP:\nIf the activity is already running, all activities above it are cleared. The existing instance is reused.\nUse Case: Resetting navigation stack (e.g., returning to home screen)
    \n\nFLAG_ACTIVITY_SINGLE_TOP:\nIf the activity is already at the top, reuse it and call onNewIntent() instead of creating a new one.\nUse Case: Avoiding duplicate activities on top.\n\nFLAG_ACTIVITY_NO_HISTORY:\nThe activity is not kept in the back stack. Once the user leaves, it\'s gone.\nUse Case: Temporary screens like login or splash.\n\nFLAG_ACTIVITY_CLEAR_TASK:\nClears all activities in the current
        task before starting the new one.\nUse Case: Starting fresh after logout or error recovery.\n\nFLAG_ACTIVITY_EXCLUDE_FROM_RECENTS:\nPrevents the activity from appearing in the recent apps list.\nUse Case: For sensitive or utility screens.</string>
</resources>